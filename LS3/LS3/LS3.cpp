#include <iostream>
#include <clocale>

int main()
{
    setlocale(LC_ALL, "Russian");// Русский язык

    // задание 1,4:
    std::cout << "Задание 1,4:" << std::endl;
    extern const int a;         // Считываем const переменные из другого .срр файла
    extern const int b;
    extern const int c;
    extern const int d;
    std::cout << "Решение через static_cast <float> ():   " << a * (b + (static_cast <float>(c) / d)) << std::endl;
    printf("Решение через float ():\t\t\t%2.3f\n\n", a * (b + (float(c) / d)));

    // задение 2:
    std::cout << "Задание 2:" << std::endl;
    int num = 19;               // Число для сравнения (разница = 2)
    (num <= 21) ? std::cout << "Число меньше, разница = " << 21 - num << std::endl :        // Если число меньше 21 - выводиться разница 
        std::cout << "Число больше, двойная разница = " << 2 * (num - 21) << std::endl;     // Если число меньше 21 - выводиться двойная разница        
    num += 5;                   // num = 24 (разница = 3)
    (num <= 21) ? std::cout << "Число меньше, разница = " << 21 - num << std::endl :
        std::cout << "Число больше, двойная разница = " << 2 * (num - 21) << std::endl;

    // задание 3:
    std::cout << std::endl << "Задание 3:" << std::endl;
    int arr[3][3][3] = {0};     // Объявляем, инициализируем массив arr[3][3][3] 
    arr[1][1][1] = 5;           // Записывает значение в "центр куба"
    int *pArr;                  // Объявляем указатель
    pArr = & arr[1][1][1];      // Присваиваем указателю адрес элемена [1][1][1] массива arr
    std::cout << "Значение ячейки [1][1][1] = " << *pArr << std::endl;
    int* pArr2 = &arr[0][0][0]; // Второй способ
    pArr2 += 13;                // Одна плоскость куба - 9 переменных, + 4 переменных путь от [0][0] значения в плоскости до центра [1][1] 
    std::cout << "Другой способ:" << std::endl << "Значение ячейки [1][1][1] = " << * pArr2 << std::endl;
    
    // Пробовал способ аналогичный описанному в "Основы Cpp Вебинар 3.pdf" на стр. 14:
    // Эксперементальным путём выявил, что он работает аналогично вышеуказанному спсобу 2 ( pArr2 )
    // Так как запись типа pArr3[1][1][1] выдаёт ошибку
    // Если я не прав в данном вопросе - прошу рассказать как правильно рабоать с 2х, 3х мерным индексированным указателем
       //   вывел для себя формулу вычисления номера ячейки от начального элемента [0][0][0]
       //   [z][y][x] - адрес искомой ячейки [c][b][a] - размер массива
       //   номер ячейки от элемента [0][0][0] равен z*(b*a) + y*(a) + x
       //   при увеличении массива ещё на одно измерение:
       //   [u][z][y][x], [d][c][b][a], формула будет иметь данный вид: u*(c*b*a) + z*(b*a) + y*(a) + x
    int* pArr3 = nullptr;
    arr[1][2][1] = 4;    //  1*9 + 2*3 + 1 = 16
    arr[2][0][2] = 6;    //  2*9 + 0*3 + 2 = 20
    arr[1][0][1] = 7;    //  1*9 + 0*3 + 1 = 10
    pArr3 = & arr[0][0][0];
    std::cout << pArr3[16] << " " << pArr3[20] << " " << pArr3[10]; // проверка верности расчетов
    // П.С. было интересно это сделать для себя, решил поделиться с вами
}